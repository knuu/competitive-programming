# div2 250 OkonomiyakiShop

- 解法
    1. 可能な組合せについて全て試せば良い
    2. div1 250のK=2の場合と考えて、二分探索しても良い
- タグ: シミュレーション
- レベル: 1


# div2 500 LostCharacter

- 解法
    - 1つ1つの文字列について、該当文字列の?を全てaに、それ以外の文字列の?をzに変換してソートしたときの該当文字列が何番目か調べる。
- タグ: 貪欲、文字列
- レベル: 2

# div2 1000 TreeCutting

- 解法
    1. アイデア: 根付き木で葉から順番にnumを足していって、0になったとき枝を切断する
        - まず、適当な頂点を根(ここでは頂点0)とした根付き木を作る
        - また、num[i]について、num[i] > 0のときは、num[i]--しておく
        - 頂点vからDFSし、返り値を合計した値とnum[v]の値の和をDFSの値として返す
            - ただし、子をDFSした値とnum[v]のうち、0以上のものが2個以上ある場合、または、子をDFSした値とnum[v]のうち、0以上のものが1個で、かつ、返り値とnum[v]の合計が0より小さくなる場合はIMPOSSIBLEとしてDFSの返り値をINFにする
            - DFSの返り値が0となる場合は、vとその親とのエッジを切断することに相当する
        - 0からDFSした値が0のときはPOSSIBLEで、それ以外のときはIMPOSSIBLEである
        - O(|V|)
    2. 枝を切断し、切断後の部分グラフがOK(部分グラフのvでnum[v]の合計が0)かどうか調べ、部分グラフについて再帰的に枝を切断していく。O(EV logE logV)くらい？
- 感想
    - 2の解法が出来そうだけど実装厳しそうだなあと思っていたところ、1の解法をTawaraさんから聞いて感動した
        - まあ証明がまだわかってないけど、反例が思いつかないし、Run System Testも通ったので一旦はよしとしよう
- タグ: グラフ、木、DFS
- レベル: 3

# div1 250 OkonomiyakiParty

- 解法
    - サイズをソートし、前から順番に、最小のサイズをosize[i]としたときの最大のサイズを二分探索で求めて、組合せが何通りあるか求める。
- タグ: 数学、組合せ、二分探索
- レベル: 2
