# 0067 The Number of Island

- 問題
    - 島の数を数えよ
- 解法
    - 深さ優先探索
- 感想
    - 昔、解こうとしたときは、dfsを知らなくて解けなかった模様
- タグ: 深さ優先探索
- レベル: 2

# 0120 Patisserie

- 解法
    - bitDP。dp\[state\]\[v\] = (状態stateのとき、v番目のケーキを最後に詰めた場合の、端から最後に使ったケーキの中心までの長さの最小値)とする。これをdp\[state\]\[u\] = min{dp\[state | 1 << u\]\[u\] + sqrt((r[v]+r[u])^2 - (r[v]-r[u])^2), (state >> u & 1) == 0}と更新することで求める。ただし、state=0のときはr[u]を、state=(1 << N)-1のときはr[v]を足す。答えはdp\[0\]\[0\]である。O(N^2 2^N)、最大ケースで6\*10^5くらい
- 感想
    - ほとんど巡回セールスマンといっしょ
- タグ: DP、巡回セールスマン問題、数学
- レベル: 3

# 0557 A First Grader

- タグ: DP、配るDP
- レベル: 2

# ALDS1 10 C Dynamic Programming - Longest Common Subsequence

- 問題
    - 2つの文字列S, Tの最長共通部分文字列の長さを求めよ
- 解法
    - 動的計画法。S[i]==T[j]のときは、dp\[i+1\]\[j+1\] = dp\[i\]\[j\] + 1, それ以外のときは、dp\[i+1\]\[j+1\] = max(dp\[i+1\]\[j\], dp\[i\]\[j+1\])で更新していく。O(|S||T|)
- タグ: DP、最長共通部分列
- レベル: 2
