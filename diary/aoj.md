# 0067 The Number of Island

- 問題
    - 島の数を数えよ
- 解法
    - 深さ優先探索
- 感想
    - 昔、解こうとしたときは、dfsを知らなくて解けなかった模様
- タグ: DFS
- レベル: 2

# 0120 Patisserie

- 解法
    - bitDP。dp\[state\]\[v\] = (状態stateのとき、v番目のケーキを最後に詰めた場合の、端から最後に使ったケーキの中心までの長さの最小値)とする。これをdp\[state\]\[u\] = min{dp\[state | 1 << u\]\[u\] + sqrt((r[v]+r[u])^2 - (r[v]-r[u])^2), (state >> u & 1) == 0}と更新することで求める。ただし、state=0のときはr[u]を、state=(1 << N)-1のときはr[v]を足す。答えはdp\[0\]\[0\]である。O(N^2 2^N)、最大ケースで6\*10^5くらい
- 感想
    - ほとんど巡回セールスマンといっしょ
- タグ: DP、巡回セールスマン問題、数学
- レベル: 3

# 0530 Pyon-Pyon River Crossing

- 解法
    - DP
    - dp\[i\]\[j\]\[k\] = (k回一行飛ばしのジャンプをして、i行目でj番目の列にいるときの最小の危険度)とする。
    - このとき、
        - dp\[i+1\]\[j\]\[k\] = min(dp\[i+1\]\[j\]\[k\], dp\[i\]\[prev\]\[k\] + prevからjに移動するときの危険度) (prevはi行目の石のいずれか)
        - dp\[i+2\]\[j\]\[k+1\] = min(dp\[i+2\]\[j\]\[k+1\], dp\[i\]\[prev\]\[k\] + prevからjに移動するときの危険度) (prevはi行目の石のいずれか)
    - と配るDPをして更新していけばよい。
    - ただ、最初と最後は危険度が0で飛ぶことができ、最初と最後にも一行飛ばしをすることができるので、初期化をdp\[0\]\[j\]\[0\] = 0、dp\[1\]\[j\]\[1\] = 0、その他をINFとし、答えをmax({dp\[N\]\[j\]\[k\] | j<=列数、k<=m}, {dp\[N-1\]\[j\]\[k\] | j<=列数、k<m})とする必要がある。
    - O(nmk^2)
- 感想
    - わりとわかりやすいDPだが、実装が少し複雑だと思った
- タグ: DP、配るDP、貰うDP
- レベル: 2

# 0557 A First Grader

- タグ: DP、配るDP
- レベル: 2

# 0558 Cheese

- 解法
    - S->1->...->Nまで順に調べていくだけ。各i->jに対して、幅優先探索してやればよい。O(NHW)
- 類題
    - チーズごとに増える体力が異なる場合はどうか？
        - N<=10なら順列で全通り試すだけ。O(NHW+fact(N))
        - N<=16なら制約付きの巡回セールスマン問題に変換できる。O(NHW+N^2 2^N)
- タグ: BFS、グリッドグラフ
- レベル: 2

# 1335 Equal Sum Sets

- 解法
    - 組合せを全て試す
- タグ: シミュレーション、組合せ
- レベル: 2

# 2589 North North West

- 解法
    1. シミュレーションするだけ。文字列を適当にパースして、ans = 2*ans + (角度)と更新していく。
    2. (python)Fractionがあるので本当にやるだけ
- タグ: 文字列、シミュレーション、算数
- レベル: 1

# ALDS1 3 C Elementary data structures - Doubly Linked List

- 解法
    - dequeのような、先頭と最後の挿入・削除がO(1)でできるようなデータ構造を用いる
- タグ: deque
- レベル: 2

# ALDS1 4 D Search - Allocation

- 問題
    - N個の荷物を順番に重さ制限のあるトラックに積み込む。荷物の重さとトラックの台数Kが与えられたとき、トラックの重さ制限は最低どれくらいでないといけないか？
- 解法
    - 二分探索する。重さをPと決めたときに、各重さがP以下でありかつ、荷物をK台以下のトラックに詰め込めるかどうかを調べる。O(N log max(W))
        - 二分探索+貪欲法の典型問題
- タグ: 二分探索、貪欲
- レベル: 2

# ALDS1 5 B Recursion / Divide and Conquer - Merge Sort

- 問題
    - マージソートの比較回数とソート結果を求めよ
- 解法
    1. 書いてあるアルゴリズムを実装するだけ
    2. merge(left, mid, right)において、比較回数はleft-rightなので、merge関数を書かずに、比較回数としてleft-rightだけを数えて、ソートはライブラリ関数でやればよい
- タグ: ソート、マージソート
- レベル: 1

# ALDS1 5 D Recursion / Divide and Conquer - The Number of Inversions

- 問題
    - 転倒数を求めよ
- 解法
    - Fenwick Treeするだけ
- タグ: Fenwick Tree
- レベル: 2

# ALDS1 7 A Tree - Rooted Trees

- 問題
    - 木が与えられる。情報(親、深さ、ノードタイプ:根or内部ノードor葉、子)を出力せよ。
- 解法
    - 親: グラフが与えられたときに記憶
    - ノードタイプ: 与えられた子を見てまず葉か内部ノードかを見る。その後、親を持たないノードを見つけて、根とする
    - 深さ: グラフを構成した後に、根から探索
- タグ: グラフ、再帰、木
- レベル: 2

# ALDS1 7 B Tree - Binary Trees

- 問題
    - 二分木が与えられる。情報(親、兄弟、深さ、高さ、ノードタイプ:根or内部ノードor葉)を出力せよ。
- 解法
    - 親・兄弟: グラフが与えられたときに記憶
    - ノードタイプ: 与えられた子を見てまず葉か内部ノードかを見る。その後、親を持たないノードを見つけて、根とする
    - 深さ・高さ: グラフを構成した後に、根から探索、返り値で高さを調べる
- タグ: グラフ、再帰、木
- レベル: 2

# ALDS1 7 C Tree - Tree Walk

- 問題
    - 木をPreOrder, InOrder, PostOrderで歩け
- 解法
    - 再帰で辿る順序を変えるだけ
- タグ: 再帰、木、グラフ
- レベル: 2

# ALDS1 9 C Heaps - Priority Queue

- 問題
    - 優先度付きキューで操作を行え
- 解法
    - シミュレーション
- タグ: シミュレーション
- レベル: 1

# ALDS1 10 C Dynamic Programming - Longest Common Subsequence

- 問題
    - 2つの文字列S, Tの最長共通部分文字列の長さを求めよ
- 解法
    - 動的計画法。S[i]==T[j]のときは、dp\[i+1\]\[j+1\] = dp\[i\]\[j\] + 1, それ以外のときは、dp\[i+1\]\[j+1\] = max(dp\[i+1\]\[j\], dp\[i\]\[j+1\])で更新していく。O(|S||T|)
- タグ: DP、最長共通部分列
- レベル: 2

# DPL 2 A Permutation/Path - Traveling Salesman Problem

- 問題
    - N頂点(Nは15以下)の重み付き有向グラフが与えられる。ある頂点から出発し、拡張点を一度ずつ通って出発点へ戻る閉路で、最短となるものの距離を求めよ
- 解法
    1. dp\[すでに訪れた頂点集合\]\[現在地\] = vから残りの頂点を通って0に帰るときの最短距離 として、メモ化再帰を行う、O(N 2^N)
    2. 配列dpの置き方は同じで、うしろからdpを実行する(ループを回す)。集合を扱う場合はこれができる？
- 類題
    1. 完全グラフ(つまり、条件を満たす閉路が必ずある場合)ならどうか
        - あんまり変わらなさそう
    2. 幾何的な場合はどうか
        - 近似はある
- 知見
    1. 集合を整数のビット表現で表してdpをする手法がある(ビットDP)
    2. ビットの扱い方
        - ビットSのi番目が立っているか: (S>>i)&1
        - ビットSのi番目を立てる: S|(1<<i)
        - ビットSのNビットが全て立っているか: (1<<N)-1==S
- タグ: DP、bitDP
