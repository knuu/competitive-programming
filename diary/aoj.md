# 0067 The Number of Island

- 問題
    - 島の数を数えよ
- 解法
    - 深さ優先探索
- 感想
    - 昔、解こうとしたときは、dfsを知らなくて解けなかった模様
- タグ: DFS
- レベル: 2

# 0120 Patisserie

- 解法
    - bitDP。dp\[state\]\[v\] = (状態stateのとき、v番目のケーキを最後に詰めた場合の、端から最後に使ったケーキの中心までの長さの最小値)とする。これをdp\[state\]\[u\] = min{dp\[state | 1 << u\]\[u\] + sqrt((r[v]+r[u])^2 - (r[v]-r[u])^2), (state >> u & 1) == 0}と更新することで求める。ただし、state=0のときはr[u]を、state=(1 << N)-1のときはr[v]を足す。答えはdp\[0\]\[0\]である。O(N^2 2^N)、最大ケースで6\*10^5くらい
- 感想
    - ほとんど巡回セールスマンといっしょ
- タグ: DP、巡回セールスマン問題、数学
- レベル: 3

# 0530 Pyon-Pyon River Crossing

- 解法
    - DP
    - dp\[i\]\[j\]\[k\] = (k回一行飛ばしのジャンプをして、i行目でj番目の列にいるときの最小の危険度)とする。
    - このとき、
        - dp\[i+1\]\[j\]\[k\] = min(dp\[i+1\]\[j\]\[k\], dp\[i\]\[prev\]\[k\] + prevからjに移動するときの危険度) (prevはi行目の石のいずれか)
        - dp\[i+2\]\[j\]\[k+1\] = min(dp\[i+2\]\[j\]\[k+1\], dp\[i\]\[prev\]\[k\] + prevからjに移動するときの危険度) (prevはi行目の石のいずれか)
    - と配るDPをして更新していけばよい。
    - ただ、最初と最後は危険度が0で飛ぶことができ、最初と最後にも一行飛ばしをすることができるので、初期化をdp\[0\]\[j\]\[0\] = 0、dp\[1\]\[j\]\[1\] = 0、その他をINFとし、答えをmax({dp\[N\]\[j\]\[k\] | j<=列数、k<=m}, {dp\[N-1\]\[j\]\[k\] | j<=列数、k<m})とする必要がある。
    - O(nmk^2)
- 感想
    - わりとわかりやすいDPだが、実装が少し複雑だと思った
- タグ: DP、配るDP、貰うDP
- レベル: 2

# 0557 A First Grader

- タグ: DP、配るDP
- レベル: 2

# 0558 Cheese

- 解法
    - S->1->...->Nまで順に調べていくだけ。各i->jに対して、幅優先探索してやればよい。O(NHW)
- 類題
    - チーズごとに増える体力が異なる場合はどうか？
        - N<=10なら順列で全通り試すだけ。O(NHW+fact(N))
        - N<=16なら制約付きの巡回セールスマン問題に変換できる。O(NHW+N^2 2^N)
- タグ: BFS、グリッドグラフ
- レベル: 2

# 1140 Cleaning Robot

- 問題
    - H\*W(それぞれ20以下)の盤面が与えられる。盤面には、スタート地点、綺麗なタイル、汚れたタイル、障害物が与えられる。スタート地点から始めて、汚れたタイルを全て通ったときの最短距離を求めよ。
- 解法
    - スタート地点、汚れたタイルからの距離を全て計算し、距離を行列で持っておき、汚れたタイルを状態としたbitDP。汚れたタイルをD個とすると、O(DWH+D^2\*2^D)
- タグ: DP、bitDP、幅優先探索
- レベル: 3

# 1156 Twirling Robot

- 問題
    - 盤面(H\*W)とロボットが左上に右向きで与えられる。目的は右下のマスにたどり着くことである。各マスには動作が書かれていて、その動作をそのまま実行する場合は移動にかかるコストが0であるが、マスに書かれているものとは異なる動作を実行した場合、移動にかかるコストは移動の種類iについてC\[i\]かかる。移動にかかるコストを最小にするとき、そのコストを求めよ。
- 解法
    - dist\[r\]\[c\]\[d\] = (マス(r,c)で向きdのときの最小コスト)として、最短距離問題を解けばよい。O(HW log HW)
- 感想
    - 方向を考える実装が面倒
- タグ: グラフ、グリッドグラフ、最短距離
- レベル: 3

# 1163 Cards

- 問題
    - 整数が書かれた赤と青のカード(それぞれ500枚以下)が与えられる。1より大きい公約数を持つ赤と青のカードでペアを作ったとき、最大何組のペアができるか？
- 解法
    - 二部マッチング。「約数が1より大きい」は「gcdが1より大きい」と同値なので、各カードについて、gcdを調べて辺を貼る。O(|V||E|^2)
    - 辺をはるかどうかは各数の約数について、それぞれ全て調べていってもよい。
- 感想
    - 二部マッチングの問題を始めて解いた。
    - ライブラリゲー
- タグ: グラフ、フロー、二部マッチング
- レベル: 3

# 1335 Equal Sum Sets

- 解法
    - 組合せを全て試す
- タグ: シミュレーション、組合せ
- レベル: 2

# 2011 Gather the Maps!

- 問題
    - N個(50以下)の巻物を1人のところに集めたい。ある日に集められる人(巻物)のインデックスが与えられるので、最短何日で巻物を集められるか？
- 解法
    - has\[i\] = {i番目の人が持つことができる巻物の集合} とする。このとき、各日ごとに、順に、巻物iがある日に集められるならば、その日に集められる各巻物kについて、has\[k\] = has\[k\] OR {i} OR has\[i\]と更新し、もし、全て集められた人がいるならばそこで終了する。最大D日とすると、O(N^2 D)
- 感想
    - 初め、UnionFindを使おうとしていたけれど、実装して出してみたらWAした
- タグ: シミュレーション、全探索
- レベル: 2

# 2153 Mirror Cave

- 問題
    - H\*W(各50以下)の盤面が2つ与えられる。各盤面でスタート地点が与えられるので、そこからスタートして盤面で左右対称に移動することを繰り返したときに、各盤面で定められたゴールに同時に付くことができるか？但し、左右対称の移動とは、上下の移動では同じ方向に進み、左右の移動では反対の方向に進むことを指す。また、片方が移動によって壁にぶつかる場合、片方が壁にぶつかって止まったまま、もう片方だけ移動することもできる。
- 解法
    - 幅優先探索するだけ。O((WH)^2)
- 感想
    - 左右対称と壁をどう実装するか考えるだけの実装ゲー
- タグ: 幅優先探索
- レベル: 2

# 2332 Space-Time Sugoroku Road

- 解法
    1. マスvの目が0のときは、vからv+1〜v+6まで重み1の辺を、マス目がp(!=0)のときはvからv+pに重み0の辺を貼って、0からN-1の最短距離を求める。O(NlogN)
    2. ループ除去+BFS。O(N)
- 感想
    - DPだと思ってしまって筋が悪かった
- 類題
    1. サイコロの目(1〜K)が一般の場合は？
        - 2はO(NK)とかになりそう？
        - 1は枝の分だけ計算量が増えそう？O(ElogE)？
    2. サイコロの目(K以下)のうち、使うものを出来るだけ少なくしたい場合は？
        - 全探索だとKの指数オーダーかかる
    3. 使った目を求めよ
        - 最短距離だと経路復元
        - BFSで経路復元ってできるんだろうか？        
- タグ: グラフ、最短距離、Dijkstra法、幅優先探索、ループ
- レベル: 2

# 2589 North North West

- 解法
    1. シミュレーションするだけ。文字列を適当にパースして、ans = 2*ans + (角度)と更新していく。
    2. (python)Fractionがあるので本当にやるだけ
- タグ: 文字列、シミュレーション、算数
- レベル: 1

# ALDS1 3 C Elementary data structures - Doubly Linked List

- 解法
    - dequeのような、先頭と最後の挿入・削除がO(1)でできるようなデータ構造を用いる
- タグ: deque
- レベル: 2

# ALDS1 4 D Search - Allocation

- 問題
    - N個の荷物を順番に重さ制限のあるトラックに積み込む。荷物の重さとトラックの台数Kが与えられたとき、トラックの重さ制限は最低どれくらいでないといけないか？
- 解法
    - 二分探索する。重さをPと決めたときに、各重さがP以下でありかつ、荷物をK台以下のトラックに詰め込めるかどうかを調べる。O(N log max(W))
        - 二分探索+貪欲法の典型問題
- タグ: 二分探索、貪欲
- レベル: 2

# ALDS1 5 B Recursion / Divide and Conquer - Merge Sort

- 問題
    - マージソートの比較回数とソート結果を求めよ
- 解法
    1. 書いてあるアルゴリズムを実装するだけ
    2. merge(left, mid, right)において、比較回数はleft-rightなので、merge関数を書かずに、比較回数としてleft-rightだけを数えて、ソートはライブラリ関数でやればよい
- タグ: ソート、マージソート
- レベル: 1

# ALDS1 5 D Recursion / Divide and Conquer - The Number of Inversions

- 問題
    - 転倒数を求めよ
- 解法
    - Fenwick Treeするだけ
- タグ: Fenwick Tree
- レベル: 2

# ALDS1 7 A Tree - Rooted Trees

- 問題
    - 木が与えられる。情報(親、深さ、ノードタイプ:根or内部ノードor葉、子)を出力せよ。
- 解法
    - 親: グラフが与えられたときに記憶
    - ノードタイプ: 与えられた子を見てまず葉か内部ノードかを見る。その後、親を持たないノードを見つけて、根とする
    - 深さ: グラフを構成した後に、根から探索
- タグ: グラフ、再帰、木
- レベル: 2

# ALDS1 7 B Tree - Binary Trees

- 問題
    - 二分木が与えられる。情報(親、兄弟、深さ、高さ、ノードタイプ:根or内部ノードor葉)を出力せよ。
- 解法
    - 親・兄弟: グラフが与えられたときに記憶
    - ノードタイプ: 与えられた子を見てまず葉か内部ノードかを見る。その後、親を持たないノードを見つけて、根とする
    - 深さ・高さ: グラフを構成した後に、根から探索、返り値で高さを調べる
- タグ: グラフ、再帰、木
- レベル: 2

# ALDS1 7 C Tree - Tree Walk

- 問題
    - 木をPreOrder, InOrder, PostOrderで歩け
- 解法
    - 再帰で辿る順序を変えるだけ
- タグ: 再帰、木、グラフ
- レベル: 2

# ALDS1 9 C Heaps - Priority Queue

- 問題
    - 優先度付きキューで操作を行え
- 解法
    - シミュレーション
- タグ: シミュレーション
- レベル: 1

# ALDS1 10 C Dynamic Programming - Longest Common Subsequence

- 問題
    - 2つの文字列S, Tの最長共通部分文字列の長さを求めよ
- 解法
    - 動的計画法。S[i]==T[j]のときは、dp\[i+1\]\[j+1\] = dp\[i\]\[j\] + 1, それ以外のときは、dp\[i+1\]\[j+1\] = max(dp\[i+1\]\[j\], dp\[i\]\[j+1\])で更新していく。O(|S||T|)
- タグ: DP、最長共通部分列
- レベル: 2

# DPL 2 A Permutation/Path - Traveling Salesman Problem

- 問題
    - N頂点(Nは15以下)の重み付き有向グラフが与えられる。ある頂点から出発し、拡張点を一度ずつ通って出発点へ戻る閉路で、最短となるものの距離を求めよ
- 解法
    1. dp\[すでに訪れた頂点集合\]\[現在地\] = vから残りの頂点を通って0に帰るときの最短距離 として、メモ化再帰を行う、O(N 2^N)
    2. 配列dpの置き方は同じで、うしろからdpを実行する(ループを回す)。集合を扱う場合はこれができる？
- 類題
    1. 完全グラフ(つまり、条件を満たす閉路が必ずある場合)ならどうか
        - あんまり変わらなさそう
    2. 幾何的な場合はどうか
        - 近似はある
- 知見
    1. 集合を整数のビット表現で表してdpをする手法がある(ビットDP)
    2. ビットの扱い方
        - ビットSのi番目が立っているか: (S>>i)&1
        - ビットSのi番目を立てる: S|(1<<i)
        - ビットSのNビットが全て立っているか: (1<<N)-1==S
- タグ: DP、bitDP

# GRL 6 A Network Flow - Maximum Flow

- 問題
    - 最大流問題を解け
- 解法
    - Ford-FulkersonなりDinicなりを使う
- 感想
    - pythonのライブラリは前から持っていたけど、今回はC++ライブラリを作成した
- タグ: グラフ、フロー、最大流問題
- レベル: 3

# GRL 7 A Matching - Bipartite Matching

- 問題
    - 二部グラフの最大マッチングを求めよ
- 解法
    - 片方をsourceに、もう片方をsinkに繋いで最大フローを求める
- 感想
    - フローのライブラリを作るついでに二部マッチングのライブラリも作った
- タグ: グラフ、フロー、二部マッチング
- レベル: 3
