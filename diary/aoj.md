# 0067 The Number of Island

- 問題
    - 島の数を数えよ
- 解法
    - 深さ優先探索
- 感想
    - 昔、解こうとしたときは、dfsを知らなくて解けなかった模様
- タグ: 深さ優先探索
- レベル: 2

# 0120 Patisserie

- 解法
    - bitDP。dp\[state\]\[v\] = (状態stateのとき、v番目のケーキを最後に詰めた場合の、端から最後に使ったケーキの中心までの長さの最小値)とする。これをdp\[state\]\[u\] = min{dp\[state | 1 << u\]\[u\] + sqrt((r[v]+r[u])^2 - (r[v]-r[u])^2), (state >> u & 1) == 0}と更新することで求める。ただし、state=0のときはr[u]を、state=(1 << N)-1のときはr[v]を足す。答えはdp\[0\]\[0\]である。O(N^2 2^N)、最大ケースで6\*10^5くらい
- 感想
    - ほとんど巡回セールスマンといっしょ
- タグ: DP、巡回セールスマン問題、数学
- レベル: 3

# 0530 Pyon-Pyon River Crossing

- 解法
    - DP
    - dp\[i\]\[j\]\[k\] = (k回一行飛ばしのジャンプをして、i行目でj番目の列にいるときの最小の危険度)とする。
    - このとき、
        - dp\[i+1\]\[j\]\[k\] = min(dp\[i+1\]\[j\]\[k\], dp\[i\]\[prev\]\[k\] + prevからjに移動するときの危険度) (prevはi行目の石のいずれか)
        - dp\[i+2\]\[j\]\[k+1\] = min(dp\[i+2\]\[j\]\[k+1\], dp\[i\]\[prev\]\[k\] + prevからjに移動するときの危険度) (prevはi行目の石のいずれか)
    - と配るDPをして更新していけばよい。
    - ただ、最初と最後は危険度が0で飛ぶことができ、最初と最後にも一行飛ばしをすることができるので、初期化をdp\[0\]\[j\]\[0\] = 0、dp\[1\]\[j\]\[1\] = 0、その他をINFとし、答えをmax({dp\[N\]\[j\]\[k\] | j<=列数、k<=m}, {dp\[N-1\]\[j\]\[k\] | j<=列数、k<m})とする必要がある。
    - O(nmk^2)
- 感想
    - わりとわかりやすいDPだが、実装が少し複雑だと思った
- タグ: DP、配るDP、貰うDP
- レベル: 2

# 0557 A First Grader

- タグ: DP、配るDP
- レベル: 2

# 0558 Cheese

- 解法
    - S->1->...->Nまで順に調べていくだけ。各i->jに対して、幅優先探索してやればよい。O(NHW)
- 類題
    - チーズごとに増える体力が異なる場合はどうか？
        - N<=10なら順列で全通り試すだけ。O(NHW+fact(N))
        - N<=16なら制約付きの巡回セールスマン問題に変換できる。O(NHW+N^2 2^N)

# ALDS1 10 C Dynamic Programming - Longest Common Subsequence

- 問題
    - 2つの文字列S, Tの最長共通部分文字列の長さを求めよ
- 解法
    - 動的計画法。S[i]==T[j]のときは、dp\[i+1\]\[j+1\] = dp\[i\]\[j\] + 1, それ以外のときは、dp\[i+1\]\[j+1\] = max(dp\[i+1\]\[j\], dp\[i\]\[j+1\])で更新していく。O(|S||T|)
- タグ: DP、最長共通部分列
- レベル: 2
