# div2 A. Arrays

- 問題
    - それぞれ昇順ソートされた、数列Aからk個選んだ部分列A'と数列Bからl個選んだ部分列B'に対して、B'の任意の要素がA'のどの要素よりも大きくなるように、A'とB'を選ぶことはできるか？
- 解法
    - A, Bはソートされているので、A\[k-1\] < B\[len(B)-l\]であるかを調べればよい。これが成り立てば、部分列はA' = {A[0], ..., A\[k-1\]}, B' = {B[len(B) - l], ..., B[len(B) - 1]} ととれる。N = max(len(A), len(B))とすると、入力にO(N)、その他はO(1)
- 類題
    1. 部分列として使って良い数字が、A[0]はa[0]個、A[1]はa[1]個...という形で与えられるとする場合はどうか？
        - Aで使うことができるものをソートしておいて、前から順に使えるものの個数を足していく。同様にBも後ろから累積和を求め、A[累積和がkを超えたところ] < B[累積和がlを超えたところ]で比較する。O(N)

# div2 B. Order Book

- 問題
    - 指令と値段と量がN($10^3$個以下)で与えられる。指令はSかBとする。指令が同じで値段が同じものは量をまとめ、Sの値段が小さいものからs個、Bの値段が大きいものからs個をそれぞれ値段の降順に出力せよ。ただし値段はP($10^5$以下)以下とする。
- 解答
    1. 大きさPの配列を2つ(BのためとSのため)持っておいて、値段が同じものの個数をまとめる。Sは0から、BはPから順にたどっていき、個数が0個以上の商品を出力し、s個出力したところでやめる。O(N+P+s)
    2. キーを値段として2つ辞書を作り、Sはキーの小さい方から、Bはキーの大きい方から出力する。C++だとmapのイテレータを順にたどるだけでいけるので、おそらくO(N+s)で、pythonだと、key値を取り出してソートする必要があるので、O(NlogN+s)
- 類題
    - Pが大きくなった場合
        - 2で解けば良い
- 知見
    - map型は、キー値の小さい方からイテレータでループが回せる。

# div1 A. Lengthening Sticks

- 問題
    - 3辺a, b, cと長さl(全て$3\cdot10^5$以下)が与えられる。lを分割してa+la, b+lb, c+lc(ただし、0<=la+lb+lc<=l)としたとき、3辺a+la, b+lb, c+lcが三角形をなすような組は何通りあるか。
- 解法
    1. 可能な組合せから、三角形をなさないものを引く。可能な組合せは、lをla, lb, lc, unusedに分けると考えると、異なる4個のものから、重複を許してl個取る重複組合せだから、4Hl=l+3C3=(l+3)(l+2)(l+1)/6通り。ここで、laを固定し、l+laを最長辺とすると、3辺が3角形をなさないための条件は、b+lb + c+lc <= a + la(三角形の成立条件)よって、lb+lc <= max(a+la-b-c, 0)である。ただし、la+lb+lc <= lより、lb+lc <= l-laなので、まとめると、lb+lc <= min(a+la-b-c, l-la)となる。よって、条件を満たさない三角形は、x=min(max(a-b-c + la, 0), l-la)として重複組合せを考えると、3Hx=x+2C2=(x+2)(x+1)/2通りとなる。これは、b+lb, c+lcが最長辺の場合も同じなので、la, lb, lcをそれぞれ0からlまで変化させて、各辺が最長辺のとき(aだとa+la-b-c>=0のとき)だけ引いていく。O(l)。
- 類題
    - 直角三角形はどうか、正三角形はどうか、二等辺三角形はどうか、四角形はどうか。
        - 直角三角形は、可能な整数の比が出せるはずなので、それを求めておいて考えればいけそう？。正三角形は、辺の長さでループすればよい。O(a+b+c+l)。二等辺三角形は、la, lb, lcをループするときに、辺の組合せ計3通りで場合分けして考えればよさそう。O(l)。四角形はわからん。

# div1 B. Minimization

- 問題
    - 長さN($3\cdot10^5$以下)の数列Aと整数k($3\cdot10^5$以下)与えられる。数列Aを
    $$\sum_{i=1}^{n-k}\left|A[i]-A[i+k]\right|$$
    が最小となるように並べ替えたとき、その値を求めよ。
- 解法
    1. n/k+1人のグループ(大きいグループ)をn%k個、n/k人のグループ(小さいグループ)をk-n%k個つくり、各グループ内の最大値-最小値の総和の最小値を求めると言い換えられる。Aをソートしておいて、小さい方から適当に大きいグループと小さいグループを作っていった場合が最小であると考えられるので動的計画法が使える。小さいグループの数をs、大きいグループの数をlと置くとdp\[l+1\]\[s+1\] = min(dp\[l\]\[s+1\] + 次に大きいグループを作った場合の値, dp\[l+1\]\[s\] + 次に小さいグループを作った場合の値)で求めることができる。$O((n\%k)\cdot(k-n\%k))$で、$k^2$で抑えられるので$O(k^2)$
- 類題
    - 最大となる場合はどうか？
